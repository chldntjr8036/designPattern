# Prototype Pattern 

* 클래스로부터 인스턴스를 생성하는게 아니라 인스턴스로부터 별도의 인스턴스를 만든다.

<hr/>

## 왜 필요한가? 어떤 상황에 쓰이는가?

*  이 패턴은 나도 확 와닿지가 않았다. 우선 이 예제에선 어떤 맥락으로 이 패턴이 쓰였는지 분석해보자.

<hr/>   

1. 예제 시나리오 
    * Manager라는 컨테이너가 존재한다. 이 클래스는 인스턴스의 복제가 생성을 매개하는 클래스다.
    * Prototype 인터페이스는 하위 클래스들의 원형같은 존재. Cloneable 인터페이스를 구현한다. 
    * MessageBox등의 하위 클래스는 Prototype을 구현한다. 이 클래스 내에서 생성자를 통해 많은 분기가 일어날 수 있고, 클래스 레벨에서
    많은 분기가 생겨날 수도 있다. 이 패턴은 클래스 레벨에서의 분기가 많은 떄 아주 유용해보인다. (예제는 전자의 경우다)
    
    <hr/>
    
    * 사용자는 여러 클래스를 생성할 필요가 있다.
    * 그냥 클래스를 생성하기엔 클래스 수가 너무 많아진다. Prototype 인터페이스와 확장성을 가지는 클래스를 설계하고 
    Manager에 키값과 prototype clone의 인스턴스를 저장한다.
   
    ## 여기서 그만! 쓸수록 더 장황해진다. 그냥 코드를 보자. 이 패턴이 가지는 장점이 뭔지는 알겠으나 클론된 객체에 접근할 때 많은 종류의 키값에 대해 알고 있어야 된다는 말인데, 그닥 마음에 들지 않는다. .  
    <hr/>
    
   
2. Prototype 인터페이스가 왜 존재하는가? 
    * 이 패턴은 구현해야할 클래스의 수가 엄청 많다는 전제가 깔려 있다. 그러므로 로직에 다형성을 이용해 하위 클래스와의 느슨함을 유지, 확장성까지 더하기 위함이다.
    
3. Cloneable 인터페이스에 대해
    * 위 예제에선 템플릿 역할을 하는 하위 클래스에 각기 다른 생성자 파라미터를 준 인스턴스를 각각 clone해 키값과 함계 맵에 저장했다.
    * clone()을 이용하면 해당 인스턴스의 메모리만큼 공간을 확보하고 필드값을 복사한다. 이 복사는 피상적 복사다. 객체의 경우 참조값만 복사하지, 예를 들면 배열의 경우 배열의 내용까지 복사하진 않는다. 
    * 피상적 복사 대신 완전한 복사를 하려면 clone()을 오버라이드 해야 한다.